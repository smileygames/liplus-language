# GitHub 運用ルール（Li+）

このページは、Li+ プロジェクトにおける **GitHub
上での実際の運用規則**を定義する。

ここに書かれている内容は思想や方針ではなく、
**守られない場合にレビュー・修正・差し戻しの対象となる規則**である。

------------------------------------------------------------------------

## Issue / Commit / Pull Request 共通ルール

-   すべての作業は **Issue から始める**
-   Commit / Pull Request は **必ず Issue に紐づける**
-   Issue 番号のない Commit / PR は認めない

------------------------------------------------------------------------

## ブランチ運用ルール

### ブランチ作成のタイミング

-   Issue は作業予定に関わらず作成してよい
-   ブランチは **着手直前** にのみ作成する
-   Issue ごとにブランチを即作成するとサブブランチが乱立するため

### ブランチ命名規則

GitHub の「Create a branch for this issue」形式を使う。
Issue へのリンクが自動付与される。

```
{issue-number}-{issue-title-slugified}
# 例: 317-update-lay_presentation-add-natural-attribute
```

作成コマンド：

```
gh issue develop {issue_number} -R {owner}/{repo} --name {branch-name} --base main
```

### 作業開始時の Assignee ルール

ブランチ作成（着手直前）と同時に、Issue の Assignee を `liplus-lin-lay` に変更する。
Assignee により「誰が担当中か」が明示され、並行作業の衝突を防ぐ。

```
gh api repos/{owner}/{repo}/issues/{issue_number}/assignees \
  --method POST \
  -f 'assignees[]=liplus-lin-lay'
```

------------------------------------------------------------------------

## Issue の記述

-   Issue は「要求の置き場」である
-   正解や実装方法を書く必要はない
-   以下を含めることを推奨する
    -   目的
    -   前提
    -   制約
    -   完了条件（曖昧でもよい）

------------------------------------------------------------------------

## Issue / Commit / Pull Request の形式

### Title（必須）

-   **英語**
-   **ASCII のみ**
-   **1行**
-   識別層として扱う（意味説明を含めない）

例：

```
Add placement rules to Li+ index
```

### Body（必須）

-   **日本語**
-   将来的な多言語化は許容するが、現時点では日本語を基本とする
-   意味層として扱う（背景・判断・意図を記述する）
-   以下を含めること
    -   変更内容の要約
    -   判断理由や背景（あれば）

------------------------------------------------------------------------

### 言語レイヤー分離原則（LANGUAGE_LAYER_SEPARATION）

-   Title は **識別レイヤー（ASCII 英語）**
-   Body は **意味レイヤー（日本語）**
-   識別と意味を混在させない
-   日本語タイトルは禁止
-   英語のみのBodyは禁止

------------------------------------------------------------------------

### Issue 番号（必須）

-   Commit / PR のbodyに **必ず Issue 番号を含める**
-   形式は自由だが、Issue との関連が明確であること

例：

```
Refs #159
```

------------------------------------------------------------------------

## Pull Request 追加ルール

### Pull Request Body の要約（必須）

-   **2～3行で要約を書く**
-   変更の要点と影響範囲が分かること
-   詳細説明は不要（Issue を参照する）

------------------------------------------------------------------------

## GitHub への書き込みルール

### プライマリ：git push（Claude エージェント推奨）

セッションブランチをそのまま GitHub にプッシュする。
ファイル内容がコンテキストに乗らないためトークン消費が少ない。

```
git push origin {session-branch}
# 例: git push origin claude/add-character-dialogue-ZKjl4
```

### フォールバック：GitHub API（他 AI・git 非使用環境）

git が使えない環境や、他の AI エージェントとの互換性が必要な場合に使用する。

#### 単一ファイルのコミット

```
gh api repos/{owner}/{repo}/contents/{path} \
  --method PUT \
  -f message="{commit message}" \
  -f content="{base64-encoded-content}" \
  -f branch="{branch-name}" \
  -f sha="{current-file-sha}"
```

#### 複数ファイルのコミット

```
# Step 1: ファイルごとに blob を作成
gh api repos/{owner}/{repo}/git/blobs \
  --method POST \
  -f content="{base64-encoded-content}" \
  -f encoding="base64"

# Step 2: tree を作成（全 blob をまとめる）
gh api repos/{owner}/{repo}/git/trees \
  --method POST \
  -f base_tree="{base-tree-sha}" \
  --field "tree[0][path]={file-path}" \
  --field "tree[0][mode]=100644" \
  --field "tree[0][type]=blob" \
  --field "tree[0][sha]={blob-sha}"

# Step 3: commit を作成
gh api repos/{owner}/{repo}/git/commits \
  --method POST \
  -f message="{commit message}" \
  -f tree="{tree-sha}" \
  -f "parents[]={parent-commit-sha}"

# Step 4: ブランチの ref を更新
gh api repos/{owner}/{repo}/git/refs/heads/{branch} \
  --method PATCH \
  -f sha="{new-commit-sha}"
```

> **注意（API 複数ファイル時）**: tree 作成後、コミット前にファイル数を検証すること。
> `base_tree` のファイル数より減少していた場合はコミット中止。

------------------------------------------------------------------------

## 禁止事項

-   Issue に紐づかない Commit / PR
-   日本語タイトルの Commit / PR
-   Issue 番号の記載がない Commit / PR
-   Pull Request の要約が無いもの
-   言語レイヤー分離に違反するもの
-   着手前にブランチを作成すること
-   作業開始時に Assignee を設定しないこと

------------------------------------------------------------------------

## CI 自動コメントフロー

**PR 作成直後に自動起動する。人間の指示は不要。**

1.  **PR 作成・更新時**
    -   タイトルは ASCII 英語、本文は日本語 + Issue 番号必須
    -   作成と同時に CI ループを開始する
2.  **コミットチェックランのポーリング**
    -   最新コミット SHA を取得
    -   全て `completed` になるまで待機
3.  **結論判定**
    -   `conclusion=failure` がある場合 → CI FAIL
    -   全て `success` の場合 → CI PASS
4.  **自動コメント投稿**
    -   PR にコメントとして投稿
    -   コメント内容には:
        -   CI 結果（PASS/FAIL）
        -   コミット SHA
        -   PR URL
5.  **CI FAIL 時の自動修正ループ（ループ安全制約付き）**
    -   修正を試みて新規コミットで CI を再実行
    -   同一の修正アプローチを3回繰り返したら中止する
    -   別のアプローチに切り替える（方針・対象箇所を変える）
    -   それでも収束しない場合は自動修正を停止する
    -   強制的な結論を出さない
    -   未解決状態を **Issue** にコメントとして外部化し、人間に判断を委ねる

この自動化フローにより、**PR 作成から CI 結果の確認・修正までが人間の介入なしに実行**される。
ただし、ループ安全制約に達した場合は自動停止し、人間のメンテナーへエスカレーションする。

------------------------------------------------------------------------

## Claude エージェント向け設定（AI設定レイヤー）

> このセクションは Claude エージェントへの追加指示。上記の人間向けルールを上書き・補足する。

### ブランチ命名規則（Claude 専用）

Claude Code がデフォルトで生成するセッションブランチ名をそのまま使用する。
別ブランチへのマッピングは不要。

```
claude/{task-description-SessionID}
# 例: claude/add-character-dialogue-ZKjl4
```

作成コマンド（Issue へのリンクを必ず張る）：

```
gh issue develop {issue_number} -R {owner}/{repo} --name {session-branch} --base main
```

> **順序制約**: `gh issue develop` は **GitHub への初回 push より前に実行する**。
> すでにリモートブランチが存在する場合、後から実行してもリンクは張れない。
> ブランチを削除すると、紐づく PR が **即座に自動クローズ**される。

> **セッションブランチのリモート存在について**: セッション開始時、セッションブランチはリモートに自動生成される。
> **リモートに存在すること自体は問題ではない。**
> 問題になるのは「理由なく GitHub 上にブランチが残存すること」であり、セッションブランチはその対象ではない。

セッションブランチ = GitHub ブランチ。refspec 変換は行わない。

------------------------------------------------------------------------

## レビュー承認後のマージフロー

**CI PASS かつ構造レビューで問題がなければ、実機テストより前にマージしてよい。**
実機テストは main にマージされた後の状態に対して行うものであり、マージのゲートとしては使わない。

マージコマンド：

```
gh pr merge {pr_number} -R {owner}/{repo} --squash --delete-branch
```

- squash merge を使用（merge commit は禁止）
- `--delete-branch` でブランチを同時削除する

> **注意（セッションブランチの削除）**: `gh issue develop` でリンクされたブランチを削除すると、紐づく **open issue が自動クローズ**される。
> セッションブランチが親 issue にリンクされている場合、`--delete-branch` を使ったマージは親 issue を閉じるリスクがある。
> クローズされた場合は `gh issue reopen {number} -R {owner}/{repo}` で再オープンすること。

------------------------------------------------------------------------

## sub-issue 操作ルール

### sub-issue のブランチルール

- **sub-issue にはブランチを作らない**
- ブランチを持つのは「実際に PR を出す作業単位」だけ
- セッションブランチは親 issue にリンクする（`gh issue develop` は親 issue 番号で実行）
- 複数の子 issue の作業を同じセッションブランチで進めてよい（commits で issue 番号を複数参照）

### 親 issue のクローズ条件

- 子 issue（deferred 扱いのものを除く）がすべてクローズされたら親をクローズする
- 子 issue が残っている状態で親をクローズしない

### マージ時の `--delete-branch` 禁止条件

セッションブランチが **open な親 issue にリンクされている場合**、`--delete-branch` を使ってはならない。

```
# マージ前の確認
gh api repos/{owner}/{repo}/issues/{parent_number}/sub_issues \
  --jq '.[] | select(.state=="open") | "#\(.number) \(.title)"'
# open な子 issue が残っていれば --delete-branch は禁止
```

子 issue がすべてクローズされ、親 issue もクローズ可能になったタイミングでのみ `--delete-branch` を使う。

### sub-issue API の内部 ID

`sub_issue_id` には **issue 番号ではなく内部 ID** が必要。

```
# 内部 ID の取得
gh api repos/{owner}/{repo}/issues/{number} --jq '.id'

# sub-issue の追加
gh api repos/{owner}/{repo}/issues/{parent_number}/sub_issues \
  --method POST \
  -f sub_issue_id={internal_id}
```

タイミング制約はない（issue 作成後でも追加可能）。

### 子 issue の分割原則

- **責務で分ける**（粒度で分けない）
- オブジェクト指向と同じ考え方：同じ責務なら1つの issue にまとめる
- 複数ファイルにまたがっていても責務が同じなら1つでよい
- 細分化すること自体が目的ではない
- **解釈でずれる構造は間違った構造**——正しく読めるかどうかが読む側の解釈に依存するなら、構造を見直すこと

### ブランチ削除の安全チェック

ブランチを削除する前に、linked open issue の有無を確認する。

- linked open issue が存在する場合は **警告を出してから削除**する
- `gh issue develop` でリンクされたセッションブランチの削除は、紐づく issue を自動クローズする
- `--delete-branch` 付きマージを行う前に、そのブランチが open issue にリンクされているか確認すること
